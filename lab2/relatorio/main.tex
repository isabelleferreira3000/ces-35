\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage[brazilian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{color}
\usepackage{float}
\usepackage{multirow}
\usepackage{hyperref}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}
\lstset{language=Python}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Relatório do Laboratório 1: \\ File Transfer Protocol (FTP)\\
}

\author{\IEEEauthorblockN{Isabelle Ferreira de Oliveira}
\IEEEauthorblockA{\textit{CES-35 - Engenharia da Computação 2020} \\
\textit{Instituto Tecnológico de Aeronáutica (ITA)}\\
São José dos Campos, Brasil \\
isabelle.ferreira3000@gmail.com}
}

\maketitle

\begin{abstract}
O trabalho tem como objetivo a implementação de um servidor de transferência de arquivos básico inspirado na interface do File Transfer Protocol (FTP), com os requisitos conforme apresentados no roteiro do laboratório.
\end{abstract}

\begin{IEEEkeywords}
FTP, Redes de computadores, Cliente-Servidor
\end{IEEEkeywords}

\section{Implementação}

A linguagem de programação utilizada foi Python 3, com o auxílio das bibliotecas: \textit{socket} para comunicação entre os processos, \textit{thread} para a criação das threads para cada cliente conectado ao servidor, e \textit{shutil} e \textit{os} para os comandos de manipulação de diretórios e arquivos.

\subsection{Funções auxiliares}

\begin{lstlisting}
# Server and Client code
def receive_message(conn):
    message_received = ""
    while True:
        data_received = conn.recv(16)
        message_received = message_received + data_received.decode("utf-8")
        if message_received.endswith("\r\n"):
            break
    message_received = message_received.split("\r\n")[0]
    return message_received
\end{lstlisting}

\begin{lstlisting}
# Server code
def check_authentication(conn):
	conn.sendall(bytes("user:\r\n", 'utf-8'))
	username = receive_message(conn)

	conn.sendall(bytes("password:\r\n", 'utf-8'))
	password = receive_message(conn)
	
	authenticate = False
	if username in credentials:
		if credentials[username] == password:
			authenticate = True

	return authenticate, username
\end{lstlisting}

\begin{lstlisting}
# Server code
def create_credentials():
	credentials_file = open("credentials.txt", "r")
	lines = credentials_file.readlines()
	for line in lines:
		username = line.split(" ")[0]
		password = line.split(" ")[1]
		password = password.split("\n")[0]
		credentials[username] = password
\end{lstlisting}

\begin{lstlisting}
# Client code
def get_command_line():
	line_input = input(">> ")
	comm = line_input.split(" ")[0]
	args = line_input.split(" ")[1:]
	return comm, args, line_input
\end{lstlisting}

\begin{lstlisting}
# Client code
def handle_feedback(comm, text):
	if comm == "cd" or \
	    comm == "mkdir" or comm == "rmdir" or \
	    comm == "get" or comm == "put" or \
	    comm == "delete":
		if text != "ok":
			print(text)

	elif comm == "ls":
		try:
			aux = text.split("[")[1:]
			aux = aux[0].split("]")[0]
			aux = aux.split(", ")
			for x in aux:
				x = x.split("'")[1]
				print(x)
		except:
			print(text)

	elif comm == "pwd":
		print(text)
\end{lstlisting}

\subsection{Navegação e listagem de diretórios}

\begin{lstlisting}
# Server code
if comm == "cd":
	curr_path = curr_session.current_directory

	try:
	    os.chdir(curr_path + "/" + dirname)
	    curr_path = os.getcwd()
	    curr_session.current_directory = curr_path
	    conn.sendall(bytes("ok\r\n", 'utf-8'))

	except FileNotFoundError:
	    conn.sendall(bytes("Error: directory does not exists in server \r\n", 'utf-8'))
\end{lstlisting}

\begin{lstlisting}
# Server code
elif comm == "ls":
	if len(args) != 0:
	    dirname = args[0]
	    
	    try:
	    	path = curr_session.current_directory + "/" + dirname
	    	fileslist = os.listdir(path)
			conn.sendall(bytes(str(fileslist) + "\r\n", 'utf-8'))

	    except FileNotFoundError:
			conn.sendall(bytes("Error: directory does not exists in server\r\n", 'utf-8'))
	else:
		path = curr_session.current_directory
		fileslist = os.listdir(path)
	    conn.sendall(bytes(str(fileslist) + "\r\n", 'utf-8'))
\end{lstlisting}

\begin{lstlisting}
# Server code
elif comm == "pwd":
	path = curr_session.current_directory
	conn.sendall(bytes(path + "\r\n", 'utf-8'))
\end{lstlisting}

\subsection{Manipulação de diretórios}

\begin{lstlisting}
# Server code
elif comm == "mkdir":
	try:
		path = curr_session.current_directory
	    os.mkdir(path + "/" + dirname)
	    conn.sendall(bytes("ok\r\n", 'utf-8'))

	except OSError:
	    conn.sendall(bytes("Error: directory already exists in server\r\n", 'utf-8'))
\end{lstlisting}

\begin{lstlisting}
# Server code
elif comm == "rmdir":
	try:
		path = curr_session.current_directory
	    shutil.rmtree(path + "/" + dirname)
	    conn.sendall(bytes("ok\r\n", 'utf-8'))
	
	except OSError:
	    conn.sendall(bytes("Error: directory does not exists in server\r\n", 'utf-8'))
\end{lstlisting}

\subsection{Manipulação de arquivos}

\begin{lstlisting}
# Server code
elif comm == "get":
	if check_if_file_exists(conn, filename):
		# if file not exists in local
		# or if can overwrite
	    feedback = receive_message(conn)

	    if feedback == "can get":
			path = curr_session.current_directory
			file = open(path + "/" + filename, "rb")
			aux = file.read(1024)
			while aux:
		    	conn.send(aux)
		    	aux = file.read(1024)
			conn.sendall(bytes("\r\n", 'utf-8'))
\end{lstlisting}

\begin{lstlisting}
# Client code
elif command == "get":
	# if file exists in server
	feedback = receive_message(sock)

	if feedback == "file already exists":
		# if file exists in local
		already_exists = check_if_file_already_exists(filename)

		can_get = True
		if already_exists:
			print("File already exists. Do you want to overwrite local file? [Y/N]")
			while True:
				answer = input()
				if answer.upper() == "Y":
					break
				elif answer.upper() == "N":
					can_get = False
					break
				else:
					print("Invalid answer. Please, answer with Y or N.")

		if can_get:
			sock.sendall(bytes("can get\r\n", 'utf-8'))
			f = open(str(filename), 'wb')
			aux = sock.recv(1024)
			while aux:
				f.write(aux)
				aux = sock.recv(1024)
				if aux.endswith(bytes("\r\n", 'utf-8')):
					break
			print("File downloaded!")
		else:
			sock.sendall(bytes("can not get\r\n", 'utf-8'))

	else:
		print("Error: file does not exists in server")
\end{lstlisting}

\begin{lstlisting}
# Server code
elif comm == "put":
	# if file exists in local
	feedback = receive_message(conn)

	if feedback == "files exists in local":
	    filename = filename.split("/")[-1]
	    
	    # if file exists in server
	    check_if_file_already_exists(conn, filename)

	    can_continue = receive_message(conn)
	    if can_continue == "Y":
	    	path = curr_session.current_directory
			f = open(path + "/" + filename, 'wb')
			aux = conn.recv(1024)
			while aux:
		    	f.write(aux)
		    	aux = conn.recv(1024)
		    	if aux.endswith(bytes("\r\n", 'utf-8')):
		        	break
		else:
			conn.sendall(bytes("ok\r\n", 'utf-8'))
\end{lstlisting}

\begin{lstlisting}
# Client code
elif command == "put":
	# if file exists in local
	file_exists_in_local = check_if_file_exists(filename)

	if file_exists_in_local:
		sock.sendall(bytes("files exists in local\r\n", 'utf-8'))
		
		# if file exists in server
		feedback = receive_message(sock)
		can_receive = False

		if feedback == "file already exists":
			print("File already exists. Do you want to overwrite remote file? [Y/N]")
			while True:
				answer = input()
				if answer.upper() == "Y":
					sock.sendall(bytes("Y\r\n", 'utf-8'))
					can_receive = True
					break
				elif answer.upper() == "N":
					sock.sendall(bytes("N\r\n", 'utf-8'))
					break
				else:
					print("Invalid answer. Please, answer with Y or N.")
		else:
			can_receive = True
			sock.sendall(bytes("Y\r\n", 'utf-8'))

		if can_receive:
			file = open(filename, "rb")
			aux = file.read(1024)
			while aux:
				sock.send(aux)
				aux = file.read(1024)
				sock.sendall(bytes("\r\n", 'utf-8'))
			print("File sent!")

	else:
		sock.sendall(bytes("files does not exists in local\r\n", 'utf-8'))
\end{lstlisting}

\begin{lstlisting}
# Server code
elif comm == "delete":
	try:
		path = curr_session.current_directory
	    os.remove(path + "/" + filename)
	    conn.sendall(bytes("ok\r\n", 'utf-8'))

	except OSError:
	    conn.sendall(bytes("Error: file does not exists in server\r\n", 'utf-8'))
\end{lstlisting}

\subsection{Gerenciamento de conexões}

\begin{lstlisting}
# Server code
if command == "close" or command == "quit":
	sessions.pop(conn)
	conn.close()
	break
\end{lstlisting}

\section{Diagramas de Sequência}

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.3]{diagrams/Command_cd_dirname.png}}
\caption{Sumário do modelo implementado em Keras.}.
\label{summary}
\end{figure}

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.4]{diagrams/Command_ls_dirname.png}}
\caption{Sumário do modelo implementado em Keras.}.
\label{summary}
\end{figure}

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.4]{diagrams/Command_pwd.png}}
\caption{Sumário do modelo implementado em Keras.}.
\label{summary}
\end{figure}

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.4]{diagrams/Command_mkdir_dirname.png}}
\caption{Sumário do modelo implementado em Keras.}.
\label{summary}
\end{figure}

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.4]{diagrams/Command_rmdir_dirname.png}}
\caption{Sumário do modelo implementado em Keras.}.
\label{summary}
\end{figure}

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.4]{diagrams/Command_get_filename.png}}
\caption{Sumário do modelo implementado em Keras.}.
\label{summary}
\end{figure}

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.4]{diagrams/Command_put_filename.png}}
\caption{Sumário do modelo implementado em Keras.}.
\label{summary}
\end{figure}

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.4]{diagrams/Command_delete_filename.png}}
\caption{Sumário do modelo implementado em Keras.}.
\label{summary}
\end{figure}

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.4]{diagrams/Command_close.png}}
\caption{Sumário do modelo implementado em Keras.}.
\label{summary}
\end{figure}

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.4]{diagrams/Command_open_server.png}}
\caption{Sumário do modelo implementado em Keras.}.
\label{summary}
\end{figure}

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.4]{diagrams/Command_quit.png}}
\caption{Sumário do modelo implementado em Keras.}.
\label{summary}
\end{figure}

\section{Funcionamento}

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.3]{prints/cd1.png}}
\caption{Sumário do modelo implementado em Keras.}.
\label{summary}
\end{figure}

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.3]{prints/ls1.png}}
\caption{Sumário do modelo implementado em Keras.}.
\label{summary}
\end{figure}

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.3]{prints/pwd.png}}
\caption{Sumário do modelo implementado em Keras.}.
\label{summary}
\end{figure}

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.3]{prints/mkdir1.png}}
\caption{Sumário do modelo implementado em Keras.}.
\label{summary}
\end{figure}

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.3]{prints/rmdir1.png}}
\caption{Sumário do modelo implementado em Keras.}.
\label{summary}
\end{figure}

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.3]{prints/get1.png}}
\caption{Sumário do modelo implementado em Keras.}.
\label{summary}
\end{figure}

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.3]{prints/put1.png}}
\caption{Sumário do modelo implementado em Keras.}.
\label{summary}
\end{figure}

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.3]{prints/delete1.png}}
\caption{Sumário do modelo implementado em Keras.}.
\label{summary}
\end{figure}

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.3]{prints/close.png}}
\caption{Sumário do modelo implementado em Keras.}.
\label{summary}
\end{figure}

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.3]{prints/open1.png}}
\caption{Sumário do modelo implementado em Keras.}.
\label{summary}
\end{figure}

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.3]{prints/quit1.png}}
\caption{Sumário do modelo implementado em Keras.}.
\label{summary}
\end{figure}

	\subsection{Implementação da Definição da Rede Neural}
	
	Essa primeira etapa se tratou da implementação do método build\underline{\space}model() da classe DQNAgent de dqn\underline{\space}agent.py, script fornecido no código base do laboratório. Nesse método, era preciso construir uma rede em Keras de acordo com as especificações apresentadas na Tabela 3 do roteiro do laboratório \cite{roteiro}.
	
	Essa implementação foi feita de forma bastante análoga à maneira do laboratório 8 \cite{roteiro8}, ou seja, seguindo o apresentado no pseudo-código em Python a seguir.
	
\begin{lstlisting}
# Adds the first layer
model.add(layers.Dense(num_neurons,
	activation=activations.some_function,
	input_dim=state_size))

# Adds another layer (not first)
model.add(layers.Dense(num_neurons,
	activation=activations.some_function))
\end{lstlisting}

	Vale ressaltar que, para atender os critérios requisitados, some\underline{\space}function do pseudo-código acima se tratou de \textit{relu} para as duas primeiras camadas, e de \textit{linear} para terceira camada. Além disso, num\underline{\space}neurons foram 24, 24 e action\underline{\space}size para as primeira, segunda e terceira camada, respectivamente.

	Fora isso, bastou-se descomentar as linhas de criação de uma pilha linear de camadas, as linhas compilação do modelo e impressão do summary do modelo, apresentado futuramente na seção \ref{results} (Resultados e Conclusões), e a linha de retorno da função.

	\subsection{Escolha de Ação usando Rede Neural}

	Já essa etapa se tratou da implementação do método act() também da classe DQNAgent de dqn\underline{\space}agent.py. Nesse método, era escolhido e retornado uma ação de acordo com a política $\epsilon$-greedy.
	
	Essa implementação foi feita de forma bastante análoga à maneira do laboratório 12 \cite{roteiro12}. Assim, gerou-se um número aleatório entre 0 e 1 e, caso esse valor aleatório seja menor que epsilon, então uma ação aleatória é escolhida; caso contrário, é escolhida a ação gulosa, através do retorno do índice do máximo elemento do array \textit{model.predict(state)[0]}.
		
	\subsection{Reward Engineering}
	
	Nesse momento, foi implementado o método reward\underline{\space}engineering\underline{\space}mountain\underline{\space}car() de utils.py, script também fornecido no código base do laboratório. Nesse método, eram calculadas e retornadas as recompensas intermediárias "artificias", chamadas reward engineering, a fim de tornar o treino mais rápido no ambiente do Mountain Car.
	
	Essa implementação foi feita conforme as equações apresentadas na seção 4.3 do roteiro do laboratório \cite{roteiro}, ou seja, assim como apresentado no pseudo-código em Python a seguir.
	
\begin{lstlisting}
reward = reward + (position - start) * (position - start) + velocity * velocity

aux = 0
if next_position >= 0.5:
    aux = 1

reward += 50 * aux
\end{lstlisting}

	Os valores de position, start, velocity e next\underline{\space}position também eram fornecidos no roteiro \cite{roteiro}, e bastava substituí-los no pseudo-código acima.

	\subsection{Treinamento usando DQN}
	
	Bastava treinar o modelo implementado, executando o script train\underline{\space}dqn.py, também do código base, e observar os resultados e os gráficos obtidos.

	\subsection{Avaliação da Política}
	
	Bastava aplicar o modelo implementado no ambiente do Mountain Car, executando o script evaluate\underline{\space}dqn.py, também do código base, e observar a simulação, os resultados e os gráficos obtidos.

\section{Resultados e Conclusões} \label{results}

	O summary do modelo implementado em make\underline{\space}model() foi apresentado na Figura \ref{summary}, e condiz com os requisitos pedidos na Tabela 3 do roteiro do laboratório \cite{roteiro}. 

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.5]{imagens/summary.png}}
\caption{Sumário do modelo implementado em Keras.}.
\label{summary}
\end{figure}

	Já a Figura \ref{train/15} representa as recompensas acumulativas advindas do treinamento do modelo em 300 episódios. Esse resultado dependem diretamente da correta implementação e funcionamento dos métodos make\underline{\space}model() e act().
	
	Pode-se dizer que esse gráfico condiz com o esperado, uma vez que é possível notar inicialmente recompensas pequenas para os primeiros episódios e, mais ou menos a partir do episódio 80, tornou-se frequente recompensas com valores elevados, chegando a valores próximos de 40, indicando um aprendizado significantemente correto.

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.3]{imagens/train/15.png}}
\caption{Recompensa acumulativa com o passar dos episódios, no treinamento do modelo para 300 episódios.}.
\label{train/15}
\end{figure} 

	Já a aplicação do modelo implementado no ambiente do Mountain Car gerou as Figuras de \ref{dqn_evaluation} a \ref{agent_decision}.
	
	A partir da Figura \ref{dqn_evaluation}, pode-se concluir que a implementação e treino chegaram em resultados satisfatórios, uma vez que grande parte das recompensas acumuladas foi alta, próximas de 40, chegando no final de 30 episódios a uma média de 27.8, conforme apresentado na Figura \ref{evaluate_dqn_result}.
	
\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.5]{imagens/dqn_evaluation.png}}
\caption{Representação em cores da tabela de action-value calculada, para algoritmo de Sarsa.}.
\label{dqn_evaluation}
\end{figure}

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.4]{imagens/evaluate_dqn_result.png}}
\caption{Recompensa acumulada em função das iterações, para algoritmo de Sarsa.}.
\label{evaluate_dqn_result}
\end{figure}
	
	Por fim, acerca da Figura \ref{agent_decision}, pode-se observar que:
	
\begin{itemize}

\item Para velocidades para direita, quase unanimamente a decisão do carro é continuar para direita. Exclui-se disso as situações de posição muito à esquerda e velocidades altas, na qual é decidido fazer nada, e de velocidades para direita muito baixas, na qual pouquíssimas vezes o carro decide ir para esquerda, talvez já se enquadrando nas intenções descritas no próximo item.

\item Para velocidades para esquerda, as decisões do carro diferem bastante da posição na qual ele se encontra. Para posições mais a esquerda, o carro decide continuar indo para esquerda, talvez para pegar impulso da subida e, quando por fim chegar em posições mais a esquerda (consequentemente mais altas) possíveis, decidir ir com velocidade para direita. Já para posições relativamente próximas da posição objetivo, aparecem também decisões de não fazer nada, indicando que o carro irá mais para esquerda e cairá na situação anteriormente descrita, na qual ele decidirá continuar indo para esquerda e pegará o impulso da elevação.

\end{itemize}

\begin{figure}[htbp]
\centering
\centerline{\includegraphics[scale=0.5]{imagens/agent_decision.png}}
\caption{Representação em cores da tabela de greedy-policy calculada, para algoritmo de Sarsa.}.
\label{agent_decision}
\end{figure} 

Como as decisões aprendidas e tomadas pelo carro fizeram sentido e puderam ser interpretadas satisfatoriamente, pode-se dizer que a proposta do laboratório foi corretamente implementada e se mostrou satisfatória em resolver o problema proposto.
	
\begin{thebibliography}{00}
\bibitem{roteiro} M. Maximo, ``Roteiro: Laboratório 12 - Deep Q-Learning''. Instituto Tecnológico de Aeronáutica, Departamento de Computação. CT-213, 2019.

\bibitem{roteiro8} M. Maximo, ``Roteiro: Laboratório 8 - Imitation Learning com Keras''. Instituto Tecnológico de Aeronáutica, Departamento de Computação. CT-213, 2019.

\bibitem{roteiro12} M. Maximo, ``Roteiro: Laboratório 12 - Aprendizado por Reforço Livre de Modelo''. Instituto Tecnológico de Aeronáutica, Departamento de Computação. CT-213, 2019.

\end{thebibliography}

\end{document}
